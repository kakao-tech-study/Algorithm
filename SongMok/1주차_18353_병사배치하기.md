- 18353번. 병사 배치하기

    ```python
    n = int(input())
    sol = list(map(int, input().split()))
    dp = [1] * n
    for i in range(1, n):
        for j in range(0, i):
            if sol[j] > sol[i]:
                dp[i] = max(dp[i], dp[j]+1)
    
    print(n - max(dp))
    ```

  이 문제의 목표는 병사들을 내림차순으로 배치하고, 필요하면 일부 병사를 제거,

  그래서 최소한의 병사를 제거해 내림차순으로 되도록 만드는 문제이다.

  dp[i] = i번째 병사를 마지막으로 하는 가장 긴 즉,병사를 제거 할 때, 여러 내림차순 부분 수열 중 제일 긴 수열의 길이이다.

  → 예시에서, [15, 11, 4, 8, 5, 2, 4] 가 있을때,

  가능한 부분 수열들은,

  [15, 11, 4, 2] → 길이 4

  [15, 8, 5, 4] → 길이 4

  [15, 11, 8, 5, 4] → 길이 5

  이 중 길이 5인 마지막을 택해야한다.

  `dp=[1]*n`: 모든 병사는 최소한 자기 자신 하나만으로 부분 수열을 이룰 수 있으므로 1로 초기화한다. (병사 한 명만 있을때도 상관이 없도록)

  `for i in range(1, n):`  로 1부터 n-1까지 병사를 순차적으로 보면서 i 번째 병사가 이전 병사들과 어떤 내림차순 관계가 있는지 확인한다.

  `for j in range(0, i):` 로 0부터 i-1까지의 병사들과 비교하면서 `sol[j] > sol[i]` 이면 j번째 병사 뒤에 i번째 병사를 붙일 수 있다는 의미이다.

  그래서 점화식으로 DP를 갱신하면 `dp[i] = max(dp[i], dp[j] + 1)` 인데 기존의 dp[i]값과 수열에 i번째 병사를 추가한 경우의 길이를 비교해서 더 큰 값으로 갱신한다.

  그리고 마지막으로 **전체 병사수에서 최대 dp 길이를 빼면** 답(제거해야 할 병사 수)이 나온다.

    ```
    
    예제 입력 1 
    7
    15 11 4 8 5 2 4
    예제 출력 1 
    2
    ```
