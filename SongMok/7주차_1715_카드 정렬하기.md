- 1715번. 카드 정렬하기
    
    ```python
    import heapq
    
    n = int(input())
    card = []
    
    for _ in range(n):
        card.append(int(input()))
    
    heapq.heapify(card)
    
    total = 0
    
    while len(card) > 1:
        first = heapq.heappop(card)
        second = heapq.heappop(card)
    
        merge = first + second
        total += merge
    
        heapq.heappush(card, merge)
    print(total)
    ```
    
    N개의 숫자 카드 묶음이 주어졌을 때, 모든 묶음을 하나로 합치는 데 필요한 최소 비교 횟수를 구하는 문제이다.
    
    카드 묶음을 합칠 때, 두 개씩 선택하여 합치고 그 과정에서 비교 횟수가 누적됨.
    
    작은 카드 묶음끼리 먼저 합치는 것이 가장 적은 비교 횟수를 만들 수 있는 최적의 방법이다.
    
    우선순위 큐를 활용할 것이다.
    
    예제 입력
    
    ```
    3
    10
    20
    40
    ```
    
    1. (10, 20) 합치기 → 비교 횟수 = 10 + 20 = 30
    2. (30, 40) 합치기 → 비교 횟수 = 30 + 40 = 70
    3. 총 비교 횟수 → 30 + 70 = 100
    
    출력: 100
    
    1. 가장 작은 두 개의 카드 묶음을 먼저 합쳐야 최소 비교 횟수를 만들 수 있다.
    2. 우선순위 큐를 사용하면 가장 작은 두 개의 요소를 빠르게 꺼낼 수 있다.
    3. 두 묶음을 합친 후, 다시 우선순위 큐에 넣고 이 과정을 반복한다.
    4. 이 과정이 반복되면 최소 비교 횟수가 누적되며, 최종적으로 모든 카드 묶음이 하나가 될 때까지 진행한다.
    
    ```
    3
    10
    20
    40
    ```
    
    우선순위 큐 초기화
    
    초기 입력을 우선순위 큐로 변환하면?
    
    `heap = [10, 20, 40]`
    
    가장 작은 두 묶음 선택, 합치기
    
    1. `heapq.heappop()` → 가장 작은 두 개 꺼내기
    
    first = 10
    second = 20
    
    1. 두 묶음 합치기 → 10 + 20 = 30
    2. 총 비교 횟수 누적 → total = 30
    3. 합친 묶음을 다시 힙에 넣기
    
    heap = [30, 40]
    
    다시 가장 작은 두 묶음 선택, 합치기
    
    1. `heapq.heappop()` → 가장 작은 두 개 꺼내기
    
    first = 30
    second = 40
    
    1. 두 묶음 합치기 → 30 + 40 = 70
    2. 총 비교 횟수 누적 → total = 30 + 70 = 100
    3. 합친 묶음을 다시 힙에 넣기
    
    heap = [70]
    
    최종적으로 100번의 비교가 필요하다.
    
    이전 풀이(틀린 풀이):
    
    ```python
    n = int(input())
    card = []
    temp1 = 0
    
    for _ in range(n):
        card.append(int(input()))
    
    card.sort()
    
    for i in range(n):
        for j in range(i+1, n):
            temp1 += card[j]
    
    print(temp1)
    ```
    
    이 풀이를 생각한 이유
    
    1. 먼저 카드 개수를 정렬하면 작은 것부터 차례로 합치는 것이 유리할 것이라고 생각했다.
    2. 이중 반복문을 이용해 카드 묶음을 순차적으로 합치면 정답이 나올 거라 예상했다.
    
    왜 틀렸을까?
    
    이 코드의 문제점은 “최적의 순서”를 따르지 않는다.
    
    → 작은 묶음을 먼저 합쳐야 한다는 원칙을 지키지 못한다.
    
    최적의 순서는 작은 것부터 차례로 묶어야 하지만, 이중 반복문은 단순히 “정렬된 상태에서 다음 카드들을 전부 더하는 방식”을 사용하기 때문이다.
    
    ```
    3
    10
    20
    40
    ```
    
    1. (10, 20) 합치기 → 10 + 20 = 30
    2. (30, 40) 합치기 → 30 + 40 = 70
    3. 총 비교 횟수 → 30 + 70 = 100
    
    정답 출력: 100
    
    작성한 코드의 연산 과정
    
    card.sort() 후 리스트: [10, 20, 40]
    
     이중 반복문을 수행하면서 temp1 += card[j] 실행
    
    계산 과정:
    
    i=0 → card[1] + card[2] = 20 + 40 = 60
    i=1 → card[2] = 40
    총합: 60 + 40 = 100 
    
    운 좋게 정답이 나오긴 했지만, 실제로는 항상 맞는 풀이가 아니다.
    
    반례:
    
    ```
    4
    10
    20
    30
    40
    ```
    
    정답은 190이지만 틀린 풀이로는 200이 나온다.
