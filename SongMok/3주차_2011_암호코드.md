2011번. 암호코드
    
    ```python
    n = input()
    l = len(n)
    
    if n[0] == '0':
      print(0)
      exit(0)
    
    dp = [0]*(l+1)
    dp[0] = 1
    dp[1] = 1
    
    for i in range(2, l+1):
      if 1<= int(n[i-1:i])<=9:
        dp[i]+=dp[i-1]
      if 10<=int(n[i-2:i])<=26:
        dp[i]+=dp[i-2]
    
    print(dp[l]%1000000)
    ```
    
    언제나 처럼 원래는 노가다로 풀려고 했다.
    `dic = {’a’:1, ‘b’:2  … }`이런식으로…
    
    하지만 읽어보면 읽어볼수록 그런 문제가 아니란것을 직감적으로 알았다.
    
    숫자입력 → 숫자출력 문제이니 굳이 dictionary 자료형이 아니고 특정 식이 있을것임을 알았다.
    
    그래서 dp로 접근했다.
    
    하나씩 스캔해야하므로, `n = input()` 으로 문자열로 받는다. 파이썬 문자열은 리스트로 처리 가능하기때문에, 나중에 int로 변환해주면 된다로 생각했던 것 같다.
    
    그래서 예외처리는 `exit(0)` 으로 종료가 있는데,
    
    “암호가 잘못되어 암호를 해석할 수 없는 경우에는 0을 출력한다. “
    
    라는 단서조항을 보고, 0부터 시작하는 경우는 해석이 아예 안되므로, 그냥 `print(0)` 으로만 넣었더니 **틀렸다**고 한다..
    
    좀 찾아보니 `exit(0)`을 안하면 프로그램을 종료하지 않고, 계속 돌리기때문에, dp 연산을 시작할 수 있어, 틀린 연산이 될 수 있다고 한다.
    
    암튼 이후 dp에선, 각 자리수마다 넣어주고 dp[0]을 1로, dp[1]을 1로 초기화 시켜준다. 이후,
    
    `for i in range(2, l+1)` 로 2부터 n+1까지 돌려준다.
    
    ex) 25114
    
    0 개 : 경우의 수 1 (초기화) ex) 없음
    
    1 개(2) : 경우의 수 1 (초기화) ex) B
    
    2 개(25): 경우의 수 2 ex)BE, Y
    
    3 개(251): 경우의 수 2 ex)BEA, YA
     …. 
    
    이런식으로 점점 늘려가면서 경우의 수를 합산한다
    
    그래서 한자리 수 해석은 
    
    ```python
    if 1<= int(n[i-1:i])<=9:
        dp[i]+=dp[i-1]
    ```
    
    이런 식으로 해준다. 1부터 9는 전부 해석 가능하므로 9까지 전부 경우의수에 합산해준다.
    
    또 두자리는
    
    ```python
      if 10<=int(n[i-2:i])<=26:
        dp[i]+=dp[i-2]
    ```
    
    이런식으로 하는데 Z가 26이니까, 26까지만 해석이 가능하다. 따라서 26까지 범위가 된다면 경우의수에 잘 합산해준다.
    
    그리고 단서 조항에
    ”정답이 매우 클 수 있으므로, 1000000으로 나눈 나머지를 출력한다.”
    
    가 있으므로, `print(dp[l]%1000000)` 로 해준다.
    
    ```
    예제 입력 1 
    25114
    예제 출력 1 
    6
    ```
