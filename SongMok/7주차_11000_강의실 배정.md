- 11000번. 강의실 배정
    
    ```python
    import heapq
    
    n = int(input())
    lecture = []
    
    for _ in range(n):
        s,t = map(int, input().split())
        lecture.append([s, t])
    
    lecture.sort()
    
    room = []
    heapq.heappush(room, lecture[0][1])
    for i in range(1, n):
        start, end = lecture[i]
    
        if room[0] <= start:
            heapq.heappop(room)
    
        heapq.heappush(room, end)
    
    print(len(room))
    ```
    
    주어진 강의 일정에 대해 최소한의 강의실 개수를 사용하여 모든 강의를 배정해야 한다.
    
    각 강의는 시작 시간(Si)과 종료 시간(Ti) 를 가지고 있으며, 하나의 강의실에서 동시에 두 개 이상의 강의가 진행될 수 없다.
    
    → 겹치는 강의들을 최소한의 강의실에 배정하는 방법을 찾아야 한다. 
    
    예제 입력
    
    ```
    3
    1 3
    2 4
    3 5
    ```
    
    그래프 해석
    
    주어진 강의 일정을 표로 정리하면?
    
    | **강의 번호** | **시작 시간 (Si)** | **종료 시간 (Ti)** |
    | --- | --- | --- |
    | 1 | 1 | 3 |
    | 2 | 2 | 4 |
    | 3 | 3 | 5 |
    
    이 강의들을 최소한의 강의실에서 진행할 수 있도록 배치해야 한다.
    
    출력: 2
    
    이 문제는 그리디 알고리즘과 우선순위 큐를 활용해서 해결할 수 있다.
    
    1. 시작 시간이 빠른 순서로 강의를 정렬한다.
    2. 현재 진행 중인 강의실 중 가장 빨리 끝나는 강의실과 새로운 강의를 비교한다.
        1. 만약 새로운 강의의 시작 시간이 기존 강의실의 종료 시간 이후라면
            
            → 기존 강의실을 재사용
            
        2. 아니라면 새로운 강의실을 추가해야 한다.
    
    입력된 강의들을 시작 시간(Si) 기준으로 정렬하면
    
    | **강의 번호** | **시작 시간 (Si)** | **종료 시간 (Ti)** |
    | --- | --- | --- |
    | 1 | 1 | 3 |
    | 2 | 2 | 4 |
    | 3 | 3 | 5 |
    
    heapq.heappush(room, lecture[0][1]) → 종료 시간 3을 힙에 삽입
    
    `room = [3]`
    
    두 번째 강의 배정 (2, 4)
    
    가장 빨리 끝나는 강의실의 종료 시간: 3
    
    새로운 강의의 시작 시간: 2
    
    2 < 3 이므로 기존 강의실 사용 불가 → 새로운 강의실 추가
    
    `room = [3, 4]`
    
    세 번째 강의 배정 (3, 5)
    
    가장 빨리 끝나는 강의실의 종료 시간: 3
    
    새로운 강의의 시작 시간: 3
    
    3 ≤ 3 이므로 기존 강의실 사용 가능 → 가장 빨리 끝나는 강의실 제거 후, 새 강의 추가
    
    `room = [4, 5]`
    
    필요한 최소 강의실 개수는`len(room) = 2`
    
    출력: 2
