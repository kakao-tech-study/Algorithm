- 12865번. 평범한 배낭

    ```python
    n, k = map(int, input().split())
    bag = []
    dp = [0] * (k+1)
    for _ in range(n):
        w, v = map(int, input().split())
        bag.append((w,v))
    
    for w, v in bag:
        for i in range(k, w-1, -1):
            dp[i] = max(dp[i], dp[i-w]+v)
    
    print(max(dp))
    ```

  냅색 알고리즘인걸 알긴 알았으나..처음엔 방법을 찾지 못했다.

  왜냐하면

    ```python
    for i in range(k, w-1, -1):
            dp[i] = max(dp[i], dp[i-w]+v)
    ```

  이 부분에서 역방향이 아닌 순방향(`for i in range(w, k)`)로 계속 시도 했었다.

  하지만 제대로 되지않았다.

  예시로,

    ```
    4 7
    6 13
    4 8
    3 6
    5 12
    
    결과: 20
    ```

  가 있었다.

  순방향으로 순회하면, dp[i]를 갱신할 때 방금 갱신한 값을 또 참조하게 된다. 즉, 같은 물건을 두 번 선택한 것과 같은 결과가 나온다.

    ```python
    for w, v in bag:
        for i in range(k, w-1, -1):
            dp[i] = max(dp[i], dp[i-w]+v)
    ```

  즉, 이 코드 부분이 핵심인데,

  맨위의 for문은 bag 안에 w(무게)와, v(가치) 튜플을 언패킹하는 과정이고,

  이를 내부 for문은 현재 고려 중인 배낭의 무게(i) 최대 무게(k) 부터 현재 물건의 무게(w)까지 역순으로 돈다.

  이 for문이 돌때, 내부의 `dp[i] = max(dp[i], dp[i-w]+v)` 의 의미는

  `dp[i]` (현재 최대 가치) = max(`dp[i]`(현재까지 최대 가치), `dp[i-w] + v`(새로운 조합의 가치 → 현재 무게 i 를 채우기 위해 새로운 물건(w,v)을 추가한다면?))이다.

  그래서 새로운 물건을 넣었을때와 기존을 계속해서 비교하면서 역순으로 dp 내부를 채워 간다.

  **📥 물건 (6, 13) 추가**

    1. i = 7 → 6 역순으로 반복
    2. dp[7] = max(0, dp[1] + 13) → dp[7] = 13
    3. dp[6] = max(0, dp[0] + 13) → dp[6] = 13

  dp = [0, 0, 0, 0, 0, 0, 13, 13]

  **📥 물건 (4, 8) 추가**

    1. i = 7 → 4 역순으로 반복
    2. dp[7] = max(13, dp[3] + 8) → 13 (변화 없음)
    3. dp[4] = max(0, dp[0] + 8) → 8

  dp = [0, 0, 0, 0, 8, 8, 13, 13]

  **📥 물건 (3, 6) 추가**

    1. i = 7 → 3 역순으로 반복
    2. dp[7] = max(13, dp[4] + 6) → 14 (갱신)
    3. dp[3] = max(0, dp[0] + 6) → 6

  dp = [0, 0, 0, 6, 8, 8, 13, 14]

  …

  따라서, 제일 큰 경우는 14로 갱신이 된다.

  그래서 핵심 로직은,

  반복문을 역방향으로 하는 것, dp의 최대 가치를 갱신하는 과정이 중요했다.
    ```
    예제 입력1
    4 7
    6 13
    4 8
    3 6
    5 12
    예제 출력1
    14
    ```
